plugins {
    kotlin("multiplatform")
    application
}

group = "${rootProject.group}"
version = "${rootProject.version}"
val artifactName: String by extra { "${rootProject.name.lowercase()}-${project.name.lowercase()}" }

val rootPackage: String by rootProject.extra
val projectPackage: String by extra { "${rootPackage}.${project.name.lowercase()}" }
val theMainClass: String by extra { "Main" }
application {
    mainClass.set("${projectPackage}.${theMainClass}" + "Kt") // + "Kt" if fun main is outside a class
}

kotlin {
    jvmToolchain(BuildSrcGlobal.jdkVersion)
    val nativeTarget = when(BuildSrcGlobal.hostOS) {
        BuildSrcGlobal.HOSTOS.MACOS -> macosX64("native")
        BuildSrcGlobal.HOSTOS.LINUX -> linuxX64("native")
        BuildSrcGlobal.HOSTOS.WINDOWS -> mingwX64("native")
        else -> throw GradleException("Host OS is not supported in Kotlin/Native.")
    }

    nativeTarget.apply {
        binaries {
            executable {
                entryPoint = "${projectPackage}.${theMainClass.lowercase()}"
                // entry point function = package with non-inside-object main method + ".main" (= name of the main function)
                //entryPoint(theMainClass.replaceAfterLast(".", "main"))
}
        }
    }
    jvm {
        jvmToolchain(BuildSrcGlobal.jdkVersion)
        withJava()
        testRuns["test"].executionTask.configure {
            useJUnitPlatform()
        }
    }
    sourceSets {
        val nativeMain by getting
        val nativeTest by getting
        val jvmMain by getting
        val jvmTest by getting
        val commonMain by getting  { // predefined by gradle multiplatform plugin
            dependencies {
                // Versions defined in buildSrc/src/main/kotlin/DepVersions.kt
                implementation(project(":lib"))
                implementation("io.github.microutils:kotlin-logging".depAndVersion())
                implementation("com.squareup.okio:okio".depAndVersion())
                implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core".depAndVersion())
                implementation("org.jetbrains.kotlinx:kotlinx-datetime".depAndVersion())
                implementation("org.jetbrains.kotlinx:kotlinx-serialization-json".depAndVersion())
            }
        }
        val commonTest by getting {
            dependencies {
                //implementation(kotlin("test-junit"))
            }
        }
    }
}

//tasks.getByName<JavaExec>("run") {
//    classpath(tasks.getByName<Jar>("jvmJar")) // so that the JS artifacts generated by `jvmJar` can be found and served
//}

tasks {
    named<JavaExec>("run") {
        standardInput = System.`in`
        workingDir = rootProject.projectDir
        classpath += objects.fileCollection().from(
            named("compileKotlinJvm"),
            configurations.named("jvmRuntimeClasspath")
        )
        classpath += files("$buildDir/processedResources/jvm/main")
    }
    //shadowJar {
    //    manifest { attributes["Main-Class"] = theMainClass }
    //    archiveClassifier.set("fat")
    //    val jvmJar = named<org.gradle.jvm.tasks.Jar>("jvmJar").get()
    //    from(jvmJar.archiveFile)
    //    configurations.add(project.configurations.named("jvmRuntimeClasspath").get())
    //}
}

// ################################################################################################
// #####    pure informational stuff on stdout    #################################################
// ################################################################################################
tasks.register("printClasspath") {
    group = "misc"
    description = "print classpath"
    doLast {
        //project.getConfigurations().filter { it.isCanBeResolved }.forEach {
        //    println(it.name)
        //}
        //println()
        val targets = listOf(
            "metadataCommonMainCompileClasspath",
            "commonMainApiDependenciesMetadata",
            "commonMainImplementationDependenciesMetadata",
            "jvmCompileClasspath",
            "kotlinCompilerClasspath"
        )
        targets.forEach { targetConfiguration ->
            println("$targetConfiguration:")
            println("=".repeat("$targetConfiguration:".length))
            project.getConfigurations()
                .getByName(targetConfiguration).files
                // filters only existing and non-empty dirs
                .filter { (it.isDirectory() && it.listFiles().isNotEmpty()) || it.isFile() }
                .forEach { println(it) }
        }
    }
}
